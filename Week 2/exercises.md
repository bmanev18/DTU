# Exercise 1

> Let $\lambda$ be a positive integer. We define $K = M = C = \{0, 1\}^\lambda$ and consider the following algorithm:

$Keygen():$
1. Output $k \leftarrow K$

$Enc(k, m \in M):$
1. Output $\boldsymbol{k \And m}$

$Dec(k, c \in C):$
1. Output $\boldsymbol{k \And c}$

<br>

> Show that these three algorithms do not form a SKE scheme, because they are not correct. You can show this by giving an example where decryption fails.`


|  $k$  |  $m$  | $Enc(k, m)$ | $Dec(k, Enc(k, m))$ |
| :---: | :---: | :---------: | :-----------------: |
|   0   |   0   |      0      |          0          |
|   0   |   1   |      0      |          0          |
|   1   |   0   |      0      |          0          |
|   1   |   1   |      1      |          1          |

⬇️ Comparing `m` and `Dec(...)` ⬇️

| Original `m` | Final `Dec(...)` |
| :----------: | :--------------: |
|      0       |        0         |
|      1       |        0         |
|      0       |        0         |
|      1       |        1         |

The decryption fails when $k = 0$ and $m = 1$. In this case, the encryption outputs $Enc(0, 1) = 0$, and the decryption outputs $Dec(0, 0) = 0$, which does not match the original message $m = 1$. Therefore, the algorithms do not form a correct SKE scheme.

# Exercise 2

> Let $\lambda$ be a positive integer and let $S_\lambda$ be the set of all permutations on strings of length $\lambda$.
We define $M = C = \{0, 1\}^\lambda$ and consider the following algorithms:

$Keygen():$
1. Output $\pi \leftarrow S_\lambda$.

$Enc(\pi, m \in M):$
1. Output $\pi(m)$.

$Dec(\pi, c \in C):$
1. Output $\pi^{-1}(c)$.
   
   
> [!IMPORTANT]
> - The key $\pi$ is a specific permutation function. It's chosen randomly once during Keygen(). Think of $\pi$ as a fixed rule for scrambling the positions of bits. For example, if $\lambda=3$, $\pi$ might be the rule "move the first bit to position 3, the second bit to position 1, and the third bit to position 2."
> - $\pi(m)$ means applying the permutation $\pi$ to the message $m$. If $m$ is a bitstring, $\pi$ rearranges its bits according to the rule defined by $\pi$.


### Part 1
> Show that these three algorithms form an SKE scheme, i.e. that they are correct.

To show that these algorithms form a correct Symmetric Key Encryption (SKE) scheme, we must demonstrate that decrypting a ciphertext returns the original plaintext message.

**Understanding the Components:**

*   **$M = C = \{0, 1\}^\lambda$**: The message space $M$ and ciphertext space $C$ consist of all possible bitstrings of length $\lambda$.
*   **$S_\lambda$**: This is the set of all permutations on strings of length $\lambda$.
*   **$Keygen()$**: Outputs a key $\pi \leftarrow S_\lambda$, which is a random permutation from $S_\lambda$.
*   **$Enc(\pi, m)$**: For a message $m \in M$, the encryption function applies the permutation, outputting $\pi(m)$.
*   **$Dec(\pi, c)$**: For a ciphertext $c \in C$, the decryption function applies the inverse permutation, outputting $\pi^{-1}(c)$.

**Proof of Correctness:**

For any key $\pi$ generated by $Keygen()$ and any message $m \in M$, the correctness property requires that:
$$Dec(\pi, Enc(\pi, m)) = m$$

Let's verify this by substituting the definitions of the `Enc` and `Dec` functions:

1.  The encryption of a message $m$ is $c = Enc(\pi, m) = \pi(m)$.
2.  The decryption of the resulting ciphertext $c$ is $Dec(\pi, c) = Dec(\pi, \pi(m))$.
3.  By definition, $Dec(\pi, \pi(m))$ applies the inverse permutation: $\pi^{-1}(\pi(m))$.
4.  Applying a permutation and its inverse consecutively yields the original input. Therefore, $\pi^{-1}(\pi(m)) = m$.

$$Dec(\pi, Enc(\pi, m)) = \pi^{-1}(\pi(m)) = m$$

> [!NOTE]
> Since the decryption of an encrypted message correctly restores the original message, the scheme is correct.


### Part 2
> Let $L_{OTS-0}$ and $L_{OTS-1}$ be the two worlds in the left-or-right one-time security game. Show that the defined three algorithms are not one-time indistinguishable, i.e., that $L_{OTS-0} \not\equiv L_{OTS-1}$. For this, write down an explicit algorithm $B$ which sends one query to its black box library. Based on the response $c$, $B$ outputs 0 if it thinks that it talked to $L_{OTS-0}$ or 1 if it thinks that it talked to $L_{OTS-1}$. How likely is it that $B$ gives the right answer?

Okay, let's show that this permutation-based encryption scheme is *not* one-time indistinguishable. This means an adversary `B` can distinguish between the two worlds ($L_{OTS-0}$ and $L_{OTS-1}$) with a probability significantly better than 1/2.

**Recall the Left-or-Right (LOTS) Game:**

The adversary `B` gets to choose two messages, $m_0$ and $m_1$, of equal length.
Then, `B` sends these messages to a library.
The library either:
* **$L_{OTS-0}$ World:** Generates a key $\pi$, encrypts $m_0$ (i.e., $c = Enc(\pi, m_0)$ ), and sends `c` back to `B`.
* **$L_{OTS-1}$ World:** Generates a key $\pi$, encrypts $m_1$ (i.e., $c = Enc(\pi, m_1)$ ), and sends `c` back to `B`.
  
`B`'s goal is to determine whether it's talking to the $L_{OTS-0}$ world or the $L_{OTS-1}$ world. If `B` can do this with probability significantly greater than 1/2, the scheme is not one-time indistinguishable.

**Why this scheme is NOT one-time indistinguishable:**

The core vulnerability here is that permutations preserve the *number of 0s and 1s* in a bitstring. If you have a string with three 0s and two 1s, any permutation of that string will still have three 0s and two 1s. The "composition" or "Hamming weight" of the string remains unchanged.

**Algorithm B:**

Let $\lambda$ be the length of the bitstrings. 

1.  **`B` chooses $m_0$ and $m_1$:**
2.  
    *   Let $m_0$ be a bitstring consisting of all zeros: $m_0 = 0^\lambda$. The number of 1s in $m_0$ is 0.
    *   Let $m_1$ be a bitstring consisting of $\lambda-1$ zeros and a single 1: $m_1 = 0^{\lambda-1}1$ (or any single 1 at any position). The number of 1s in $m_1$ is 1.

3.  **`B` sends $(m_0, m_1)$ to the library.**

4.  **`B` receives a ciphertext `c` from the library.**

5.  **`B`'s decision logic:**
    *   Count the number of 1s in `c`. Let this be `count_1s(c)`.
    *   If `count_1s(c) == 0`, `B` outputs `0` (concluding it's talking to $L_{OTS-0}$).
    *   If `count_1s(c) == λ`, `B` outputs `1` (concluding it's talking to $L_{OTS-1}$).

**How likely is it that `B` gives the right answer?**

Let's analyze the two worlds:

*   **If `B` talks to $L_{OTS-0}$:**
    *   The library encrypts $m_0$. So, $c = \pi(m_0)$.
    *   Since $m_0$ consists of all zeros ($0^\lambda$), and applying a permutation only shuffles the positions of the bits, $\pi(m_0)$ will still be $0^\lambda$.
    *   Therefore, `count_1s(c)` will be `0`.
    *   `B` will correctly output `0`.

*   **If `B` talks to $L_{OTS-1}$:**
    *   The library encrypts $m_1$. So, $c = \pi(m_1)$.
    *   Since $m_1$ consists of all ones ($1^\lambda$), and applying a permutation only shuffles the positions of the bits, $\pi(m_1)$ will still be $1^\lambda$.
    *   Therefore, `count_1s(c)` will be $\lambda$.
    *   `B` will correctly output `1`.

> [!NOTE]
> In both scenarios, `B`'s algorithm makes the correct decision with 100% certainty (probability 1).

> [!NOTE]
> Since `B` can distinguish between the two worlds with probability 1, which is significantly greater than 1/2, the permutation-based encryption scheme is **not one-time indistinguishable**. The information about the number of 1s (or 0s) in the plaintext is preserved in the ciphertext, allowing an adversary to easily determine which plaintext was encrypted if the plaintexts differ in their bit composition.


# Exercise 3
> Let $\lambda$ be a positive integer. We define $K = M = C = \{0, 1\}^\lambda$ and let $B_p$ be the probability
distribution that outputs 0 with probability $p$ and 1 with probability $1 − p$. Consider the
following algorithms:

### Part 1
> Show that these three algorithms form an SKE scheme (Correctness)

For an SKE scheme to be correct, $Dec(k, Enc(k, m))$ must always equal $m$ for any key $k$ and message $m$.

1.  **Encryption:** $Enc(k, m) = k \oplus m$
2.  **Decryption:** $Dec(k, c) = k \oplus c$

Now, let's substitute the encrypted message into the decryption function:
$Dec(k, Enc(k, m)) = Dec(k, k \oplus m)$
$Dec(k, k \oplus m) = k \oplus (k \oplus m)$

Using the properties of XOR:
*   XOR is associative: $a \oplus (b \oplus c) = (a \oplus b) \oplus c$
*   XORing a bit with itself results in 0: $k[i] \oplus k[i] = 0$
*   XORing a bit with 0 results in the original bit: $0 \oplus m[i] = m[i]$

So, $k \oplus (k \oplus m) = (k \oplus k) \oplus m$.
Since $k \oplus k$ results in a vector of all zeros ($0...0$ of length $\lambda$), we have:
$(k \oplus k) \oplus m = 0...0 \oplus m = m$

Therefore, $Dec(k, Enc(k, m)) = m$. The scheme is correct and forms a valid Symmetric Key Encryption scheme.

---

### Part 2
> Let $\lambda = 3$ and $A$ queries $L_{OTS-Real}$ with $m = 111$. Compute the probability of each possible ciphertext.

Here, $L_{OTS-Real}$ means the library uses the actual $Keygen$, $Enc$, $Dec$ algorithms.

$m = 111$, $k$ is a vector of length $\lambda = 3$. Each $k[i]$ is drawn from $B_{0.75}$, meaning $P(k[i]=0) = \frac{3}{4}$ and $P(k[i]=1) = \frac{1}{4}$.

The ciphertext $c = k \oplus m$. Since $m = 111$, $c[i] = k[i] \oplus 1$.

Let's compute $c[i]$ based on $k[i]$:
*   If $k[i] = 0$, then $c[i] = 0 \oplus 1 = 1$.
*   If $k[i] = 1$, then $c[i] = 1 \oplus 1 = 0$.

So, the probability distribution for $c[i]$ is:
*   $P(c[i]=1) = P(k[i]=0) = 3/4$
*   $P(c[i]=0) = P(k[i]=1) = 1/4$

Since each bit of $k$ is chosen independently, the bits of $c$ are also independent. For $\lambda = 3$, there are $2^3 = 8$ possible ciphertexts. Let's list them and their probabilities:

| k       | P(k)                                     | c = k ⊕ 111 | P(c)                                     |
| :------ | :--------------------------------------- | :---------- | :--------------------------------------- |
| 000     | $(3/4)^3 = 27/64$                        | 111         | $(3/4)^3 = 27/64$                        |
| 001     | $(3/4)^2 \times (1/4) = 9/64$            | 110         | $(3/4)^2 \times (1/4) = 9/64$            |
| 010     | $(3/4) \times (1/4) \times (3/4) = 9/64$ | 101         | $(3/4) \times (1/4) \times (3/4) = 9/64$ |
| 011     | $(3/4) \times (1/4)^2 = 3/64$            | 100         | $(3/4) \times (1/4)^2 = 3/64$            |
| 100     | $(1/4) \times (3/4)^2 = 9/64$            | 011         | $(1/4) \times (3/4)^2 = 9/64$            |
| 101     | $(1/4) \times (3/4) \times (1/4) = 3/64$ | 010         | $(1/4) \times (3/4) \times (1/4) = 3/64$ |
| 110     | $(1/4)^2 \times (3/4) = 3/64$            | 001         | $(1/4)^2 \times (3/4) = 3/64$            |
| 111     | $(1/4)^3 = 1/64$                         | 000         | $(1/4)^3 = 1/64$                         |
| **Sum** | **1**                                    | **Sum**     | **1**                                    |

So, these are the probabilities for each of the 8 possible ciphertexts when $m=111$ is encrypted by $L_{OTS-Real}$.

---

### Part 3

>Based on the algorithm A, consider a new algorithm $B$ that sends $m = 111$, waits
for the response $c$ from the library. $B$ outputs 1 if $c = m$ and 0 otherwise. What is
the probability that $B$ outputs 1 with $L_{OTS-Real}$, and what is the probability when it
interacts with $L_{OTS-Rand}$?

Algorithm $B$:
*   Sends $m = 111$ to the library.
*   Receives $c$.
*   Outputs $1$ if $c = m$ (i.e., $c = 111$).
*   Outputs $0$ otherwise.

**Probability that $B$ outputs $1$ with $L_{OTS-Real}$:**

From the table above, the ciphertext $c = 111$ occurs when $k = 000$.
$P(c=111 | L_{OTS-Real})$ = $P(k=000)$ = $P(k[0]=0) \times P(k[1]=0) \times P(k[2]=0)$
Since $P(k[i]=0) = 3/4$:
$P(c=111 | L_{OTS-Real}) = (3/4)^3 = 27/64$

So, the probability that $B$ outputs $1$ with $L_{OTS-Real}$ is **$\frac{27}{64}$**.

**Probability that $B$ outputs $1$ with $L_{OTS-Rand}$:**

$L_{OTS-Rand}$ means the library ignores $m$ and just outputs a random bitstring $c$ of length $\lambda$.
In this case, $c$ is chosen uniformly at random from $\{0, 1\}^3$.
There are $2^3 = 8$ possible bitstrings, each with probability $1/8$.
$m = 111$.

$B$ outputs $1$ if $c = m$ (i.e., $c = 111$).
The probability of a specific 3-bit string being chosen uniformly at random is $1/8$.
$P(c=111 | L_{OTS-Rand}) = 1/8$

So, the probability that $B$ outputs $1$ with $L_{OTS-Rand}$ is $\boldsymbol{\frac{1}{8}}$.

---

### Part 4

> Show that the three algorithms Keygen, Enc, Dec are not real-or-random secure, i.e.
that $L_{OTS-Real} \not\equiv L_{OTS-Rand}$. For this, apply the real-or-random-secure definition to
the algorithm $B$ and show why it breaks security.

The scheme is not real-or-random secure (i.e., $L_{OTS-Real} \not\equiv L_{OTS-Rand}$) if there exists an algorithm $B$ such that:

$| P(B \text{ outputs } 1 | L_{OTS-Real}) - P(B \text{ outputs } 1 | L_{OTS-Rand}) | > \text{negligible}(\lambda)$

In our case, $\lambda = 3$. We've already computed these probabilities for our specific algorithm $B$:

*   $P(B \text{ outputs } 1 | L_{OTS-Real}) = \frac{27}{64}$
*   $P(B \text{ outputs } 1 | L_{OTS-Rand}) = \frac{1}{8}$

Let's compute the difference:
$|\frac{27}{64} - \frac{1}{8}| = |\frac{27}{64} - \frac{8}{64}| = \frac{19}{64}$

This value, $\frac{19}{64}$, is a significant and non-negligible probability. It is a constant value and does not become smaller as $\lambda$ increases (in fact, it generally wouldn't be negligible even for larger $\lambda$ if $p$ is fixed at $0.75$).

**Why this breaks security:**

The definition of real-or-random security (often called IND-CPA security for symmetric schemes when restricted to a single query) states that an adversary should not be able to distinguish whether it's receiving a real encryption of its chosen message ($L_{OTS-Real}$) or a completely random string ($L_{OTS-Rand}$) with probability significantly better than 1/2.

Our algorithm $B$ makes this distinction easily. If $B$ gets a $111$ ciphertext, it's about 3.375 times more likely to be from $L_{OTS-Real}$ than from $L_{OTS-Rand}$. This means $B$ can make an educated guess. If $c = 111$, $B$ would confidently output $0$ ($L_{OTS-Real}$). If $c \neq 111$, $B$ might output $1$ ($L_{OTS-Rand}$).

The non-negligible difference ($\frac{19}{64}$) clearly shows that $B$ has a significant advantage over simply guessing (which would have a difference of 0). Therefore, the encryption scheme is **not real-or-random secure**. The biased key generation (where 0s are more likely than 1s) directly leaks information about the plaintext-ciphertext relationship, allowing $B$ to distinguish the real encryption from random noise.

`
